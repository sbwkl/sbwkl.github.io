# 《编译原理》 day 54

今天是读《编译原理》的逻辑第 54 天，学习垃圾回收，面试必背内容之一。

垃圾回收要求语言具有类型安全，即任何数据都能确定类型。确定类型那数据占用的长度也确定，java 的数据类型在运行时确定，叫做动态类型语言。

类型不安全的语言没法使用垃圾回收机制，比如 C 和 C++，这俩理论上可以访问任何内存位置，牛逼是真牛逼，苦逼也是真苦逼。

这节给应用程序起了新名字 mutator（增变者），这名字感觉有点中二，不知道要干啥。不过既然是龙书的操作，一定有它的深意吧。

上次见到这个词好像在 clickhouse 的文档里，那时就觉得好奇怪的名字。

垃圾回收器性能指标

+ Overall Execution Time: 总运行时间，越短越好，很大程度上看能不能利用好存储子系统
+ Space Usage: 避免产生碎片
+ Pause Time: 停顿时间，越短越好，每次看到这个都会联想到 dio 爷的 The world，不过 dio 爷最长 9 秒，显然不符合要求
+ Program Locality: 垃圾回收器控制数据存放位置，需要为增变者的局部性负责

几个指标之间有冲突，多数对象具有朝生夕死的特性，降低回收频率，可使总开销变少，但空间使用率下降，局部性变差，停顿时间变长，又是一个鱼与熊掌的故事。

垃圾回收器有两种思路，引用计数法和可达性分析。

引用计数法挺可怜的，每次见它出现，都是当可达性分析的陪衬，这关系就像春园阳平和冈崎朋也。

引用计数法要求每个对象保存引用计数，通过增变者行为维护

+ Object Allocation: 新对象设置计数 1
+ Parameter Passing: 传递给函数的每个对象计数 +1
+ Reference Assignments: u = v，v 指向的对象计数 +1，u 本来指向的对象计数 -1
+ Procedure Returns: 局部变量指向的对象计数 -1，如果 n 个局部变量指向同一个对象计数 -n
+ Transitive Loss of Reachability: 当一个对象的计数变成 0，这个对象指向的每个对象计数 -1

引用计数法有两个缺点，不能处理循环引用，开销比较大，每次赋值都有额外开销。

引用计数也有优点，它以增量的形式回收垃圾，单次回收耗时短，实时回收垃圾，空间利用率高，几乎无停顿。

可达性分析有 root set（根集）包含可以被程序直接访问的数据，从根集出发，能被引用到的对象标为可达，剩下的对象全回收。

编译器优化会让可达性分析变得困难，有些引用被放置在寄存器，编译器有时会指向对象的中间位置，为了可达性分析正常运行，需要做一些限制

+ 编译器限制垃圾回收机制只能在程序中的某些代码点上被激活，这些点上没有「隐藏」的引用，难道是安全点
+ 编译器写出一些信息供垃圾回收器恢复引用
+ 编译器确保当垃圾回收器被激活时每个可达对象都有一个引用指向它的基地址

增变者行为同样改变可达对象集合

+ Object Allocations: 增加可达对象
+ Parameter Passing and Return Values: 可达性不变
+ Reference Assignments: u = v 有两个效果，效果一，v 指向的对象 v'，只要 u 可达，v' 也可达。效果二，u 本来指向的对象 u'，如果 u 是最后一个引用，u' 不可达，顺带只能通过 u' 引用到达的对象都不可达
+ Procedure Returns: 保存局部变量的活动记录被弹出，同赋值效果二

封面图：Twitter 心臓弱眞君 @xinzoruo