# 数据库存储和索引

这篇是《数据库系统概念》第 10，11 章的学习笔记。虽然数据库用了很多年，但是除了用法，对数据库本身了解不多，以至于和同事吃饭吹牛的时候只能听他们侃侃而谈，我只能在旁边直呼 666。

了解数据库存储先要了解存储介质，现在比较多的是机械硬盘和固态硬盘，固态硬盘性能好比较贵，机械硬盘反过来。先说机械硬盘，它有一个机械臂组件和若干个盘片，数据记录在盘片上，机械臂的末端是一个读写头，悬浮在盘片上，当盘片旋转时读写头就能读取到数据。为了方便管理，盘片会划分为磁道（就是一个个同心圆），磁道再被划分成扇区。

![](https://files.mdnice.com/user/18103/0b8451d4-5a7e-4c42-9325-35b70b99c7ac.jpg)

机械硬盘读取数据分三步

1. 机械臂找到对应的磁道
2. 盘片旋转找到起始地址
3. 盘片旋转读取扇区数据

这三步里第一步最耗时，盘片越大越慢，其次是第二步，最后是第三步。这里可以用坐地铁打比方，当想乘坐地铁去一个地方的时候，去地铁站是最费时的，尤其距地铁站很远。然后是等地铁费时，如果上一班刚走就更悲剧了，一旦坐上了地铁，那么坐三个站还是五个站其实区别不大。

因此为了优化性能，每次读取的时候会把整个扇区都读到内存里，反正费不了多长时间，不读白不读。也因此内存和磁盘之间的数据交换通常按「块」来，「块」是定长的存储单元，比如 4-8k。这个「块」有时叫 block 的，有时叫 page 估计不严谨的时候可以混着用。

另外操作系统有局部性原理：时间局部性（Temporal Locality）和空间局部性（Spatial locality）。空间局部性说的是，当前被读取到的地址，后续操作高概率读取附近的地址，程序员被要求写出局部性高的代码。

固态硬盘是基于闪存（flash memory）技术的一种硬盘，和机械硬盘原理不一样，数据会按照 block 组织，每个 block 划分成很多个 page，读写以 page 为单位，它的写操作有点奇特，不是直接在原 page 上写而是把整个数据写到新的 page 然后擦除旧的 page。

更多的相关内容可以可以看看《计算机组成原理》6.1 章节，里面还讲了为什么 ROM 明明可以读也可以写，却叫 ROM (read only memory)。

一块硬盘的性能是有极限的，为了提高硬盘的性能和可靠性发展出了一种叫 RAID(redundant arrays of independent disks) 的技术。冗余提高可靠性，多块磁盘并行写提高性能。不同的 RAID 方案分类成不同的 RAID 等级，所以 RAID 等级之间没有明确的递进关系。

比较常见的是 RAID 1，RAID 5。RAID 1 数据按块拆分，冗余一份，相当于两块硬盘当一块用，性能和可靠性都很好，性能好是因为数据分块可以同时并行向多块硬盘写，可靠性好是因为每份数据有一份冗余，缺点是空间利用率低 50%。

RAID 5 至少三块硬盘，数据按块拆分，额外存储一份奇偶校验位用于数据重建。也就是说三块硬盘当两块用，空间利用率是 (N - 1) / N * 100%，N 是总共的硬盘数量。

RAID 5 重建数据的原理是这样的，以三块硬盘为例。

假设第一块硬盘第一个扇区的数据是  

```
10010011101110110001101...
```
第二块硬盘第一个扇区的数据是

```
10000001000000010000000...
```

那么第三块硬盘第一个扇区存放的就是校验位数据，偶数个 1 存 0，奇数个 1 存 1。

```
00010010101110100001101...
```

这样最终在每块硬盘上的数据是这样的

```
10010011101110110001101...
10000001000000010000000...
00010010101110100001101...
```

现在假设第二块硬盘损坏了

```
10010011101110110001101...
_______________________...
00010010101110100001101...
```

系统可以根据剩余的两块数据开始重建数据

```
10010011101110110001101...
1000___________________...
00010010101110100001101...
```

只要构成阵列的硬盘里仅有一份数据损坏，数据是可以重建的，直接拔掉一块硬盘换块新的进去，数据也能恢复。但是如果两份以上的数据损坏了就没办法了，所以需要任务定时扫描及时发现错误并重建。

越多的硬盘构成 RAID 5 阵列，利用率越高（N 越大 N - 1 / N 越大），代价是可靠性下降。硬盘越多，损坏超过两份的可能性就越大。

数据库记录以「块」的形式组织，对于定长记录，每块能存储的记录条数是固定的，为了方便插入和删除记录，系统维护空闲列表，记录块中的可用空间，和内存管理有点像。

![](https://files.mdnice.com/user/18103/4a1bd678-7273-4fcb-be8b-7ddc293abbff.jpg)

变长记录更复杂，用一种叫分槽的页结构（slotted-page structure）来组织记录。

![](https://files.mdnice.com/user/18103/5be208ca-83cc-4abc-b224-122d8fe54804.png)

每「块」有一个头信息，包含

1. 记录条目的数量
2. 空闲空间的末尾地址
3. 一个包含记录的位置和大小的数组

数据库记录从后往前插入，这样空闲空间一直是连续的，删除记录需要移动原来记录保证空闲空间仍然是连续的。这种结构不允许指针直接指向记录而要指向头文件中的条目。

对于 blob 和 clob 这种特别大的数据类型，记录不存储原始内容，只存储指针，保证记录大小尽量小于块大小。

数据库的索引和字典的索引原理一样。索引可以有多个层级，字典的索引除了本身还有一层 A-Z 的索引。

索引涉及一堆术语。

+ 超码（super key）：一个或多个属性的集合，可以唯一确定一条记录（这里的属性就是表字段，下同）
+ 候选码（candidate key）：最小的超码
+ 主码（primary key）：只有一个属性的超码，工作中我们一般喊主键
+ 搜索码（search key）：用来查找记录的属性
+ 复合搜索码（composite search key）：包含好几个属性
+ 顺序索引（ordered indices）：基于值的顺序排序
+ 散列索引（hash indices）：基于 hash 函数，将值均匀分布到若干个桶
+ 聚集索引（clustering index）：也叫主索引（primary index），指索引顺序和包含记录的文件顺序相同，不是主键属性也可以是主索引。
+ 非聚集索引（nonclustering index）：也叫辅助索引（secondary index），没上面这条要求就是非聚集索引。
+ 索引项（index entity）：一个搜索码 + 指向记录的指针构成一条索引项，也可以叫索引记录（index record）
+ 稠密索引（dense index）：每个搜索码的值都有索引项
+ 稀疏索引（sparse index）：部分搜索码的值有索引项
+ 多级索引（multilevel index）：索引上面还有一层索引，套娃。

没什么卵用的知识又增加了。

B+ 树索引，一种平衡树，即从根到叶子节点的路径长度相同，与二叉树不同，B+ 树分叉的数量范围是 [⌈n/2⌉, n)，n 越大，树越矮，分叉的数量叫扇出（fanout）。非叶子节点搜索码的后面跟一个指针指向下一层节点，叶子节点搜索码的前面有一个指针指向记录，叶子节点的最后一个指针指向下一个叶子结点。

把 B+ 树的非叶子节点遮住的话就是一个链表，非叶子节点的作用是为了更快的找到叶子节点。

B+ 树每个非叶子节点的扇出需要相同，如果搜索码是数字类型，这个很容易满足，数字类型占用的空间相同。如果是字符串类型就比较麻烦了，因为字符串长度可变，为此有一个办法是固定取字符串前 m 个字符，这样就可以保证每个节点扇出相同。这时候如果搜索码有太多的前 m 个字符相同的字符串，索引的效果就会打折扣。

![](https://files.mdnice.com/user/18103/54ac3ed8-145f-493c-89fd-58c9ae894740.jpg)

B+ 树查询过程，假设搜索值为 V 的记录，查询过程从根节点开始，寻找第一条大于等于 V 的条目，然后跳转到对应的节点，直至找到叶子节点，遍历需要的次数等于树高。另外一个节点是一次磁盘读取，没有浪费又没有冗余，优雅的雅痞。

![](https://files.mdnice.com/user/18103/25f6389b-0207-4961-b01c-4e055f354f43.jpg)

B+ 树更新操作包括插入和删除，情况就更复杂了，有兴趣的可以看原文，在 11.3.3 章节。我看不懂但我大受震撼！

散列索引用散列函数（hash function）把索引均匀分布到若干个桶，与 B+ 树需要遍历树不同，散列函数在给定值之后可以立刻定位是哪个桶。根据散列方法不同分成静态散列（static hashing）和动态散列（dynamic hashing)，区别是桶的数量是否可变。

静态散列桶数量固定，这个设计有个问题，随着数据库记录越来越多，桶就装满了，有一个办法是再弄一个溢出桶（overflow bucket）记录存到溢出桶里面，然后用一个指针指向溢出桶，但更多的溢出桶，更慢的查询速度。

静态散列在最初定义桶容量也比较复杂，定太大，浪费空间，定太小，数据一多全是溢出桶。

为了解决静态散列的问题，发明了一系列动态散列技术，其中有一种叫做可扩充散列（extendible hashing）。

可扩充散列除了有散列函数和桶以外，还有一个桶地址表记录指向桶的指针，桶地址表用散列值（二进制）的前 i 位表示，从 0 开始增长，桶满了之后会分裂成两个桶，然后 i 自增。

![](https://files.mdnice.com/user/18103/3c9abf4c-c913-46b7-903a-d470e904f937.jpg)

比如要把上面这些记录插入到大小为 1 的桶里面，流程是这样的。

最初 i = 0 就 1 个桶（2^0 = 1），桶地址表里一条记录，指向一个桶 A。

接着插入 Biology，根据桶地址表找到桶，桶没满，正常插入。

接着插入 Comp.Sci，根据桶地址找到桶 A，但是 A 已经满了，需要分裂成 A0 和 A1，i 自增，这时候桶地址表就有 2 条记录，一条 0 指向桶 A0 一条 1 指向桶 A1。原桶里的记录重新分配，Biology 存在 A0，Comp.Sci 存在 A1。

接着插入 Elec.Eng，第一位是 0 找到桶 A0 但是 A0 满了，需要分裂成 A00 和 A01，i 自增，桶地址有 4 条记录，分别是 00, 01, 10, 11。00 指向 A00，01 指向 A01，10 和 11 因为对应的桶不需要分裂，所以都指向 A1。原桶里的记录重新分配，Biology 保存在 A00，Elec.Eng 保存在 A01 其他不变。

接着插入 Finance 前 2 位是 10 找到桶 A1 但是 A1 满了，需要分裂成 A10 和 A11，因为分裂之前有 2 个指针指向这个桶，有多余的指针可以用，i 不需要自增。原桶里的记录重新分配，Comp.Sic 保存在 A11，Finance 保存在 A10。

依次类推，把所有的记录都保存到桶里。不过如果有太多的记录有相同的散列值，那分裂也救不了，再怎么分裂都被放到同一个桶里，这时候还是需要溢出桶来帮忙。

![](https://files.mdnice.com/user/18103/1face237-6ebf-472e-bf7d-18daf754479e.jpg)

位图索引（bitmap index）

无论是顺序索引还是散列索引，搜索码都建议有较高的区分度，最好是超码之类的，但是总有一些搜索码没有那么高的区分度，比如性别、VIP 等级、订单状态之类的，这时候前面讨论的索引就不好使了，可以试试位图索引。位图索引要求每条记录都有一个明确的数字代表，mysql 的自增逐渐那种，然后对于某个搜索值如果记录有这个值那么就设置 1 否则设置 0。

拿性别来举例，假设这个属性有两个值 F, M，那么会有两个位图

```
F   01001110...
M   10110001...
```

上面的索引表示第 2 5 6 7 条记录性别为 F 第 1 2 3 8 条记录性别为 M，位图的下标代表了记录。

这种索引在查询结果很小的时候特别有用，比如查询男性 + VIP3 的用户数，这个时候只要拿男性的位图和 VIP3 的位图做按位与操作就能拿到结果。再者计算机的一次位操作就是 32 或者 64 比特，效率会很高。

比较悲剧的是 mysql 似乎不支持位图索引，oracle 是支持的。

索引是以额外的空间和增加插入和删除记录时间为代价来大幅减少查询时间，在查询操作能满足需求的情况下不需要添加索引。当查询时间不满足要求，需要添加索引，要考虑一些问题

1. 能不能接受定期重组索引组织
2. 插入和删除的频率
3. 能否接受以增加最坏情况访问时间为代价优化平均访问时间
4. 查询的类型

散列索引更加擅长精确匹配，遇到范围查询容易傻逼，顺序索引反过来。想想以前加索引全凭手感，惭愧惭愧。

两章看完只能用「卧槽，牛逼！」来形容，以后可以和同事们过两招了，等感受完下两章查询优化的牛逼，还能再过他两招。

题图：Photo by Pixabay from Pexels