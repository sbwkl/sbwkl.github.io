# 《编译原理》 day 3

今天是阅读《编译原理》的逻辑第 3 天，看到一个叫产生式（production）的东西，很有意思，以 Java 的 if 语句为例，大概长这个样子

```
stmt -> if ( expr ) stmt else stmt
```

代表的意思是左边的 stmt 可以用右边的表达式来表示。这里面的三个 stmt 虽然拼写一样，但表达的是不同的内容，可以把它们想象成 Stmt 类的三个对象，有时会用下标以示区别。

在这个式子里，stmt 叫做非终结符号，if ( ) else 叫做终结符号。这俩的区别就是能不能用表达式来表示，能-非终结，不能-终结。

一段程序经过解析最终由一大堆终结符组成。

举个例子

```
list -> list + digit | list - digit | digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
```

竖线表示「或」的关系，这里有 12 个终结符：0~9 + -

产生式 + 终结符集合 + 非终结符集合 + 开始符号 = grammer（文法）

从开始符号开始不断用产生式带入，所能产生的所有终结符号串的集合叫做这个文法的语言

上面这个例子能够表示 10 以内所有的加减表达式。比如表达式：9 - 5 + 2

![](4-parse-tree-1.png)

上图这种树状结构叫 parse tree（分析树）

产生式的定义需要小心二义性，比如上面的两个产生式，如果图方便这么定义

```
string -> string + string | string - string | digit
digit -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
```

还是这个表达式 9 - 5 + 2 则会有两棵分析树

![](4-parse-tree-2.png)

这样的文法需要避免

运算符的结合性和优先级，当一个操作数左右两边都有操作符，比如 （+ 5 +）操作数属于左边的叫左结合，属于右边的叫右结合，+=*/ 都是左结合的。

根据小学数学，*/ 的优先级要高于 +=，文法的产生式可以这么设计

```
expr -> expr + term | expr - term | term
term -> term * factor | term / factor | factor
factor -> digit | (expr)
```

其实我也不知道它是怎么设计出来的，但这三个产生式确实能正常工作，越往下优先级越高。

封面图：Twiter 心臓弱眞君 @xinzoruo