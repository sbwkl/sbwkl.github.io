# 《编译原理》 day 2

我工作使用的 Java 语言属于第三代语言，第一代是机器语言，只用 `xxd -b` 看过，天书，哪怕最简单的 hello world 编译出来的内容也多的一匹，gcc 悄咪咪加了一堆代码。

第二代是汇编语言，这个上学的时候听过，这门考试最后能过是因为老师大发慈悲说只要你们填了答案都算对 :joy: 。用 `objdump -d` 能看，还是天书，仅能认出 mov、add 等有限的几个指令。

第三代就熟悉多了，除了 Java 还有 C、C++、Lisp，能看懂个大概。据说 Lisp 语言非常强大，哪天有空去见识一下。

第四代是为特定应用设计的语言，比如 SQL。很长时间里我以为它仅仅是数据库的附属，在这里给它道个歉。

第五代是基于逻辑和约束的语言，没听过。

编译器对编程语言非常重要，要降低高级语言执行开销提高性能，支持语言新特性，利用新硬件能力，它真的，为这个家付出了太多。编译器越强，编程人员越可以放飞自我。

编译器提高性能主要利用两个技术：parallelism & memory hierarchies。通过重排序指令，让指令并行更有效，通过调整数据布局或者访问顺序，让内存访问更有效，拥有更好的局部性。

编译器还影响新计算机的架构设计，最初编译器听计算机架构的，它说啥是啥，随后编译器越来越庞大，有些设计也要听一下编译器的意见，不然辛苦设计出来的新特性程序用不起来，多尴尬。

RISC 就是一个例子，在编译器之前倾向于设计 CISC 方便开发。我记得 ARM 是 RISC，x86 是 CISC。还有一个豆知识，32 位的标准是 Intel 定的，但是 64 位的标准是 AMD 定的，所以有些安装包的命名有 `_x86` 但是没有 `_x86_64` 取而代之的是 `_amd64` 其实是一回事。

一些有意思的概念，工作上没什么卵用，读文档可能会遇到。

+ Identifier: 通常是一段字符串，指向一个实体
+ Name: 包含 identifier，还可以是表达式，比如 x.y
+ Variable: 指存储中的某个位置

![](3-environment-state-1.png)

状态是变量和值都映射关系，这个定义更好的理解命令式语言。

+ Procedure: 翻译是过程，一个可以被调用的子程序，没有返回值
+ Function: 翻译是函数，通常返回某个类型
+ Method: 面向对象语言中使用，通常关联到特定的类

多数情况下混着用也没事，差不多是一回事。

语言的静态和动态，一个问题编译时可以决定的是静态，要运行时才能决定的是动态。作用域也分静态和动态，区别和前面一样。

静态作用域像空间，动态作用域像时间。静态作用域从空间找上最靠近使用位置的声明，动态作用域从时间上找最靠近使用位置的声明。

Java 的重载和重写也是作用域的一种，重载用的是静态策略，重写用的是动态策略。突然发现很多语言特性最终都能用作用域来解释。

参数传递机制

1. call-by-value: 传递过去的是一个拷贝，Java 只有值传递，干净
2. call-by-reference: 传递过去的是地址，C 语言有这种机制，我晕针（指针）
3. call-by-name: 已经不用了，有点像代码注入，用传入的参数替换掉程序代码

这也是当年背诵的八股文之一，不知道现在还有没有。

关于参数传递还有个有意思的例子，比如方法 `foo(Object x, Object y)`，正常这么定义方法 x y 肯定是两个不同的对象，但如果 x y 传同一个对象进去，可能就会产生 bug，改 x 的时候 y 其实也被改了，这个东西还有个专业都名字叫别名。

到这里第一章的内容就结束了，初步介绍编译器整体结构，给这个黑盒子打开了一条缝。

我看过的几本书都是这个模式，先总体预览，然后每个部分详细展开，展开到一定程度就开始懵逼了。

封面图：Twiter 心臓弱眞君 @xinzoruo