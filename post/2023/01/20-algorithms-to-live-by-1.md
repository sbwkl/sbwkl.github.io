# 《算法之美》 day 3

*注：这本书和算法关系不大*

今天的两章比较熟悉，排序和缓存。

每次出现排序，冒泡法总要出来挨打，这次也是，当奥巴马被问到用什么方法排序一百万个数字，他回答首先排除冒泡排序，惨冒泡惨。

常规的排序没啥说的，估计都背了好多遍了，我印象比较深的是一个诡异的排序，忘记哪本书上看到的，好像是《编程珠玑》。

它把数组的元素当另一个数组的下标，比如数组 `A = [6, 4, 1, 3]` 那么 `T[6] = 1; T[4] = 1` 等等，然后遍历数组 T 取出值为 1 的数组下标，排序就完成了。

总觉得哪里不对劲，但好像又没错。

后来发现这还真是正经的排序算法，和猴子排序这种搞笑的不一样。

这类算法不同于传统基于比较的算法，能够突破 O(n·log n) 的限制，种类还不少。

**桶排序<sup>[1]</sup>**

这是归并排序失散多年的妹妹吧

![](20-1.png)

**计数排序<sup>[2]</sup>**

![](20-2.gif)

**基数排序<sup>[3]</sup>**

![](20-3.png)

书里提到健壮性挺有趣的，它指的是比较有概率出错的情况下，结果的准确性。

比如现实中体育比赛，总有爆冷的可能，这时候需要平衡效率和健壮性。

在强调健壮性时，冒泡排序终于翻身做主把歌唱，按着归并排序摩擦，但它还不是最好的，最好的是比较计数排序<sup>[4]</sup>。

图书馆是排序应用的例子，为了方便检索图书，花了大量精力排序图书（我云的，我没在图书馆干过活）。

但这个例子中排序和缓存存在一些冲突，在计算机中缓存被证明是提高效率的利器，LRU 是简单又有效的策略，如果策略在图书馆中也生效，那么被借阅的书再次被借阅的概率很高，这时候花大精力把书放回它原来的位置是否真的更有效？

+ [1] 桶排序：*https://en.wikipedia.org/wiki/Bucket_sort*
+ [2] 基数排序：*https://en.wikipedia.org/wiki/Radix_sort*
+ [3] 计数排序：*https://en.wikipedia.org/wiki/Counting_sort*
+ [4] 比较计数排序：*https://zh.wikipedia.org/wiki/比較計數排序*

封面图：Twitter 心臓弱眞君 @xinzoruo