# 一起学离散数学：密码学

密码学可以追溯到两千多年前的凯撒大帝，他发明了一种加密方式把明文的每个字符向后移动 3 位。为了方便理解，假设凯撒大帝说英语，用字母 a-z 写信，那么如果凯撒大帝想写一封内容为 helloworld 的信，他加密后的内容应该是 khoorzruog。

为了方便运算，把 a-z 映射为数字 0-25 那么凯撒密码可以表示为 f(p) = (p + 3) mod 26。符号 mod 表示模运算，意思是除 26 取余数。比如信中的 h 对应数字 7，f(8) = (7 + 3) mod 26 = 10 对应字符 k。有加密就有解密，解密就是把加密的过程反过来 p = (f(p) - 3) mod 26。

可以用更加通用的公式表示凯撒密码 f(p) = (p + k) mod 26 其中 k 叫做安全密钥，持有相同密钥的双方可以正常加解密通信。

随着密码学的出现，同时出现了另两项技术密码分析和密码破译，光与暗总是相生相伴。其中一种破译方式是对比字符出现的概率，通过一些语料可以统计出字符的出现概率这个是已知的。然后统计出密文出现频率最高的字符，然后假设这两个字符相等，解出 k 然后进行解密，看看解出来的文字是否有意义，如果有意义认为破解完成，如果没有意义换一个字符继续试。

凯撒密码很容易被破解，直接爆破都行，反正就 26 个字母。那么就需要对凯撒密码进行加固，一种方式是调整加密公式为 f(p) = (ap + b) mod 26，叫做仿射密码（affine ciphers），加密过程依然简单，但是解密过程没有那么直观。

为了解密这里引入同余式的概念，假设 a mod m = b mod m 那么就记为 $$a \equiv b \bmod m$$ 同余式满足一些定理。

假设有 2 个同余式

$$
a \equiv b \bmod m
$$
$$
c \equiv d \bmod m
$$

那么

$$
\begin{align}
a + b &\equiv (c + d) \bmod m \\
ab &\equiv cd \bmod m \\
a + b &\equiv (a \bmod n + b \bmod n) \bmod n \\
ab &\equiv ((a \bmod n)(b \bmod n)) \bmod n \\
a^b &\equiv (a \bmod n)^b \bmod n
\end{align}
$$

这个和四则运算有点像，同样的也满足交换律、结合律和分配律。四则运算还有两个逆元：加法逆元和乘法逆元（倒数），模运算里面也有，而且这个乘法逆元是上述解密时要用的。

a 模 m 的乘法逆元和 a 满足等式

$$
\overline{a}a \equiv 1 \bmod m
$$

假设密文是 d 为了解出 p 相当于解方程

$$
ap + b \equiv d \bmod m
$$

根据前面提到的定理我们可以知道

$$
p \equiv \overline{a} (d - b) \bmod m
$$

解密的重任落到了如何求解 a 模 m 的乘法逆元上。这时候需要最大公约数上场，在我的印象中求解最大公约数的方法叫辗转相除法，就是两个数交替取余数。比如 10, 24 的最大公约数是

24 = 10 * 2 + 4

10 = 4 * 2 + 2

4 = 2 * 2 + 0

所以最大公约数 gcd(10, 24) = 2。这种算法还有一个名字叫欧几里得算法，2000 多年前就有记载了。

和最大公约数有关的还有个贝祖定理：如果 a b 是正整数，那么存在 s t 使得 gcd(a, b) = sa + tb 成立，(s, t) 叫做贝祖系数。

回到乘法逆元，我们先假设 gcd(a, m) = 1 那么根据贝祖定理存在 (s, t) 使得等式 sa + tm = 1 成立，tm 肯定整除 m 那么

$$
sa \equiv 1 \bmod m
$$

也就是说贝祖系数中的 s 就是我们需要的 a 模 m 的乘法逆元，问题转到如何求贝祖系数了。

贝祖系数的一种解法是把辗转相除法倒过来再算一遍（还有很多别的算法）。以 gcd(10, 24) 为例，辗转相除法的 3 个式子也可以写成 

4 = 24 - 10 * 2

2 = 10 - 4 * 2

0 = 4 - 2 * 2

最后一个等式丢弃不用，从倒数第二个开始，把上一个等式带入到下一个等式中，得到

2 = 10 - 4 * 2 = 10 - (24 - 10 * 2) * 2 = 5 * 10 - 2 * 24 

那么贝祖系数就是 (5, -2) 也就是说 gcd(10, 24) = 5 * 10 + (-2) * 24

到此解密需要的要素都集齐了。实际来用一下假设加密算法是 f(p) = (7p + 3) mod 26, gcd(7, 26) = 1 乘法逆元一定存在，现在收到的密文是 8 需要解密出原文是多少。

首先算出贝祖系数，先来一遍辗转相除法

26 = 7 * 3 + 5

7 = 5 + 2

5 = 2 * 2 + 1

2 = 1 * 2

丢弃最后一个等式不用，开始按顺序倒着代入得到

1 = 5 - 2 * 2 

  = 5 - (7 - 5) * 2 

  = -2 * 7 + 3 * 5 

  = -2 * 7 + 3 * (26 - 7 * 3) 

  = (-11) * 7 + 3 * 26

得出 (7, 26) 的贝祖系数是 (-11, 3) 也就是 7 模 26 的乘法逆元是 -11。现在收到的密文是 8 代入解密公式

$$

p \equiv \overline{a} (d - b) = (-11) * (8 - 3) = -55 \bmod 26

$$

因为 0 <= p < 26 所以 p = 23 。

当然针对这个例子还有一个更简单的解法，p 的取值范围就 [0, 26) 一共不过 26 个值，按照加密公式算出所有密文，保存到表里，要用的时候 select 一下就好了，哈希加密的破解用了类似方式，叫彩虹表（rainbow table）来着。

前面的加密算法都是对单个字符进行加密，为了更强的安全性，开发出分组密码（block ciphers）这种方式不再以单个字符为单位进行加密，而是以一组字符为单位进行加密。比如 4 个字符组成一组那么 helloworld 就可以分成 3 组，分别是 he llow orld 然后每个字符用 2 个数字表示，比如 a = 00, b = 01, ..., z = 25 分组的字符可以表示为 0704 11111422 14171103 在然后对这 3 组数字进行加密，这时候再统计密文频率，只能统计个寂寞。

凯撒密码和仿射密码都是私钥密码系统。这种密码系统只要知道了私钥，那么加密解密的过程都知道了。与之相对的还有公钥密码系统，比如 RSA 密码。

RSA 密码在我接触的项目中用的比较多，数据比较敏感的接口可能就会用上，比如支付啥的。RSA 秘钥有 2 个，公钥和私钥。公钥公开，交给对方用来加密数据，私钥自己保存用来解密。

RSA 的工作原理是这样的，生成 5 个数 p q n e d 其中 p q 是两个很大的质数。这 5 个数满足两个等式

$$
n = pq 
$$
$$
ed \equiv 1 \bmod (p - 1)(q - 1)
$$

假设 m 是明文，c 是密文

RSA 加密算法

$$
c = m^e \bmod n
$$

RSA 解密算法

$$
m = c^d \bmod n
$$

为了证明 RSA 加解密算法是正确的需要用到费马小定理。

费马小定理的描述是对于质数 p 任何不整除 p 的整数 m 满足等式

$$
m^{p-1} \equiv 1 \bmod p
$$

然后开始操作

$$
(m^e)^d = m^{ed} = m^{1 + k(p - 1)(q - 1)}
$$

$$
m^{ed} \bmod p = m * m^{(p - 1)k(q - 1)} \bmod p = m \bmod p
$$
$$
m^{ed} \bmod q = m * m^{(q - 1)k(p - 1)} \bmod q = m \bmod q
$$

因为 p q 互质

$$
m^{ed} \equiv m \bmod pq
$$

$$
c^d \bmod n = (m^e \bmod n)^d \bmod n = (m^{ed}) \bmod n = m \bmod n
$$

m 的取值范围是 [0, n) 所以

$$
m = c^d \bmod n
$$

也就是解密算法。对于 RSA 密码系统来说 n e c 这 3 个信息是暴露的，但是解密需要的 d 要通过 p q 来计算，对于破解者来说先通过 n 分解出 p q 这是非常庞大的计算量，运行时间至少是按年来算的，所以在超级牛逼的计算机出来前 RSA 算法是安全的，另外定期更换密钥是好习惯。第一次看到这里的时候震惊了，万万没想到本来一个无解的东西居然也能被利用起来。

为了求证下，我用 python 库 cryptography 读取了本地 ssh-keygen 生成的公钥和私钥，的确是这么回事。

```python
from cryptography.hazmat.primitives import serialization

with open(".ssh/id_rsa", "rb") as key_file:
    pk = serialization.load_ssh_private_key(
        key_file.read(),
        password=None,
    )
    print('p =', pk.private_numbers().p)
    print('q =', pk.private_numbers().q)
    print('d =', pk.private_numbers().d)
    print('n =', pk.public_key().public_numbers().n)
    print('e =', pk.public_key().public_numbers().e)

with open(".ssh/id_rsa.pub", "rb") as key_file:
    pub = serialization.load_ssh_public_key(
        key_file.read()
    )
    print('n =', pub.public_numbers().n)
    print('e =', pub.public_numbers().e)
```
输出的结果里除了 e 其他几个数字都巨长。

```
p = 21...43
q = 20...89
d = 11...25
n = 44...27
e = 65537

n = 44...27
e = 65537
```

这几个数字都很大，直接用二进制表示肯定会溢出，刚好余数可以用来表示很大的数，这块会用到中国余数定理。

中国余数定理在《孙子算经》里有描述

> 今有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二，问物几何？

>答曰：二十三。

>术曰：三三数之剩二，置一百四十；五五数之剩三，置六十三；七七数之剩二，置三十，并之，得二百三十三。以二百一十减之，即得。凡三三数之剩一，则置七十；五五数之剩一，则置二十一；七七数之剩一，则置十五。一百六以上，以一百五减之，即得。

问题翻译过来就是求解 x 满足同余式

$$
x \equiv 2 \bmod 3
$$
$$
x \equiv 3 \bmod 5
$$
$$
x \equiv 2 \bmod 7
$$

答案翻译过来就是 140 + 63 + 30 - 210 = 23。它求得是最少的数量。后半句是解题思路：就是说余数是 x, y, z 时，计算 70x + 21y + 15z 结果超过 106 就 -105 直到小于 106。

反过来理解 23 可以用 (2, 3, 2) 来表示，而且运算也可以通过余数来计算，比如 7 可以表示为 (1, 2, 0) 那么 23 + 7 = (2 + 1, 3 + 2, 2 + 0) = (0, 0, 2)。根据这个思路可以挑几个比较大的两两互质的数，比如 

$$
2^{35} - 1, 2^{34} - 1, 2^{33} - 1
$$

这 3 个数就可以表示 2 的 100 次方以内的数了，而且还可以运算，数学真是门神奇的学科。

上面的内容参考《离散数学》第 4 章，书上有更多更详细的内容，感兴趣的小伙伴可以一看，还是有很多有趣的东西的。

题图：Photo by Bella White from Pexels