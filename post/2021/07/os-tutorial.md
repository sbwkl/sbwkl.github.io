# 一个 Github 的操作系统教程

前段时间逛 github 发现了一个宝藏仓库 [os-tutorial](https://github.com/cfenollosa/os-tutorial)。看名字就知道是个教程，它手把手教你从零开始实现操作系统，在微观的视角下看一看操作系统是怎么运行的。教程已经实现的功能有

+ 引导程序
+ 16bit 切换到 32 bit
+ 中断处理
+ 键盘输入 & 屏幕输出

比较遗憾的是教程没有实现内存映射和进程管理。

这是我见过的最保姆级的教程，教程从安装环境开始，然后从简到繁分 24 个小节推进，每个小节涉及 1~3 个理论知识。教程重点在代码，理论知识需自行 Google 解决，不过作者很贴心的推荐了 3 份文档 [os-dev](http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf), [JamesM's tutorial](http://www.jamesmolloy.co.uk/tutorial_html/index.html) 和 [OSDev wiki](http://wiki.osdev.org)。前 2 份文档是作者重点参考的对象，也是这个教程灵感的来源，最后一份是 wiki 想要的名词解释这里都有。

从 12 小节开始使用 C 语言编写代码，第一次看到这里的时候满脑子想的都是苦日子终于熬出头了，终于能用相对熟悉的语言写代码了，不容易啊。C 语言是一门伟大的语言，记得有个大佬说过，无论你现在用什么语言开发，了解一点 C 语言总是好的。还有编译器，等以后有时间把《编译原理》安排上。

从 15 小节开始我遇到一个问题，字符 X 不在预期的位置上显示，通过 gdb 调试 position 的值是一个很大的负数，不知道什么原因，解决的办法是编译成 32 位。使用命令 `gcc -m32 -fno-pie` 和 `ld -m elf_i386` 就可以编译成 32 位的。加参数 `-fno-pie` 是为了规避 undefinde reference to _GLOBAL_OFFSET_TABLE_ 的错误。

最令我兴奋的是第 2 节和第 20 节，第 2 节通过最原始的方式在屏幕上显示「hello」字符。第 20 节能够在屏幕上显示当前按下的键盘字母，并且能够关机了，再也不是一个死循环结尾了。前者意味着它可以完成预设的任务，并返回结果，后者意味着我可以和它进行交互了。

教程让我知道电脑是怎么启动的。电脑通电后 BIOS 会率先启动，自检然后加载一个 512 字节的引导扇区，为了能够认出这是引导扇区而不是乱七八糟的数据，它会检查最后 2 个字节是不是 0xAA55 对上了才会执行代码。引导扇区初始以 16bit 模式运行，加载操作系统到内存，然后切换到 32bit 模式，最后调用操作系统的入口函数。操作系统初始化中断，内存映射等服务，然后等待用户输入，直到用户输入关机命令操作系统才会返回，然后关机断电。

教程让我更容易记住寄存器的名字，之前看《深入理解计算机系统》的时候，看到 16 个寄存器的时候是一脸懵逼的，这名字咋都没个规律的，现在才知道不是没有规律，是没有找到规律。

4 个数据寄存器 ax, bx, cx, dx 很好记就是 abcd + x 这 4 个寄存器可以理解成变量。每个寄存器可以再拆成 2 个，比如 ax 可以拆成 ah 和 al 分别表示高 8 位和低 8 位。ax 还常常用作调用函数的返回值。

2 个指针寄存器 bp, sp 分别是 base pointer 和 stack pointer 的缩写，和栈有关的都脱不开这 2 个。

2 个变址寄存器 si, di 分别是 source index 和 destination index 的缩写，这两个书上只写了可以用来传参。

32 位寄存器就是在 16 位的基础上加字符 e，比如 ax 在 32 位就是 eax。

64 位寄存器就是把 e 变成 r，比如 eax 在 64 位就是 rax，另外多了 r9 ~ r15 8 个寄存器。
其他还有控制寄存器、段寄存器啥的，没了解。

这个教程也让我感受到当身处荒漠时，工具是多么的重要。它可能不是构建操作系统的必要组件，但是它在构建的过程中起了至关重要的作用，比如打印函数能够帮助我们理解和排查代码的问题。总之顺着作者的思路过一遍整个教程一定会有收获，要是能把代码默写出来那就更刺激啦。

最后在列一下我使用的环境
+ Thinkpad-x220i 古董笔记本
+ Ubuntu 20.04
+ gcc 9.3.0
+ nasm 2.14.02
+ qemu 4.2.1