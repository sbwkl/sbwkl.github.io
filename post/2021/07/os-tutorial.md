前段时间逛 github 发现了一个宝藏项目 [os-tutorial](https://github.com/cfenollosa/os-tutorial)。这个项目手把手教你从零开始开始实现操作系统，比较遗憾的是教程没有实现虚拟内存和进程。作者已经实现的功能有

+ 引导程序
+ 16bit 切换到 32 bit
+ 中断处理
+ 键盘输入 & 屏幕输出

这是我见过的最保姆级的教程，作者从安装环境开始，然后从简到繁分 24 个小节推进，每个小节涉及 1~3 个理论知识，项目重点在代码，理论知识需自行 Google 解决，当然作者还很贴心的推荐了 3 份文档 (os-dev)[http://www.cs.bham.ac.uk/~exr/lectures/opsys/10_11/lectures/os-dev.pdf], (JamesM's tutorial)[http://www.jamesmolloy.co.uk/tutorial_html/index.html] 和 (OSDev wiki)[http://wiki.osdev.org/]。前 2 份文档是作者重点参考的对象，也是这个项目灵感的来源，最后一份是 wiki 想要的名词解释这里都有。

从 12 小节开始使用 C 语言编写代码，第一次看到这里的时候满脑子想的都是苦日子终于熬出头了，终于能用相对熟悉的语言写代码了，不容易啊。C 语言是一门伟大的语言，记得有个大佬说过，无论你现在用什么语言开发，了解一点 C 语言总是好的。当然还有编译器，等以后有时间把《编译原理》安排上。

从 15 小节开始我遇到一个问题，字符 X 不在预期的位置上，通过 gdb 调试 position 的值是一个很大的负数，不知道什么原因，解决的办法是编译成 32 位。使用命令 `gcc -m32 -fno-pie` 和 `ld -m elf_i386` 就可以编译成 32 位的。加参数 `-fno-pie` 是为了规避 undefinde reference to _GLOBAL_OFFSET_TABLE_ 的错误。

这个教程让操作系统启动过程更加具体，电脑通电后 BIOS 会率先启动，然后先加载一个 512 字节的引导扇区，为了能够认出这是引导扇区而不是乱七八糟的数据，它会检查最后 2 个字节是不是 0xAA55 对上了才会执行。引导扇区初始以 16bit 模式运行，加载操作系统到内存，然后切换到 32bit 模式，最后调用操作系统的入口函数。操作系统初始化中断，内存映射等服务，然后等待用户输入，直到用户输入关机命令操作系统才会返回。

这个教程中最令我兴奋的是第 2 节和第 20 节，第 2 章通过最原始的方式在屏幕上显示「hello」。第 20 章能够在屏幕上显示当前按下的键盘字母，并且能够关机了，再也不是一个死循环结尾了。

更容易记住寄存器的名字了，之前看《深入理解计算机系统》的时候，看到 16 个寄存器的时候是一脸懵逼的，这名字咋都没个规律的，现在才知道不是没有规律，是没有找到规律。

4 个数据寄存器 ax, bx, cx, dx 很好记就是 abcd + x 这 4 个寄存器可以理解成变量。没个寄存器可以再片成 2 个，比如 ax 可以拆成 ah 和 al 分别表示高 8 位和低 8 位。ax 还常常用作调用函数的返回值。
2 个指针寄存器 bp, sp 分别是 base pointer 和 stack pointer 的缩写，和栈有关的都脱不开这 2 个。
2 个变址寄存器 si, di 分别是 source index 和 destination index 的缩写，这两个书上只写了可以用来传参。
32 位寄存器就是在 16 位的基础上加字符 e，比如 ax 在 32 位就是 eax。
64 位寄存器就是把 e 变成 r，比如 eax 在 64 位就是 rax，另外多了 r9 ~ r15 8 个寄存器。
其他还有控制寄存器、段寄存器啥的，没了解就不献丑了。

这个教程也让我了解到当身处荒漠时，工具是多么的重要。它可能不是构建操作系统的必要组件，但是它在构建的过程中起了至关重要的作用，比如打印函数能够帮助我们理解和排查代码的问题。还有作者很早就开始组织代码，相同类型的文件放置在同一个文件夹中，为了方便后续扩展，也把自己的思想传递下去。

最后在列一下我使用的环境

+ Thinkpad-x220i 古董笔记本
+ Ubuntu 20.04
+ gcc 9.3.0
+ nasm 2.14.02
+ qemu 4.2.1